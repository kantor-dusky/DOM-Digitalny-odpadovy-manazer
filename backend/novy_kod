import argparse
import re
import sys
from pathlib import Path
import os
import cv2
import numpy as np
import psycopg2
import easyocr # type: ignore

# ===================== NASTAVENIA =====================

# Konfiguracia DB: preferuj environmentalne premenne (pre docker-compose)
DB_CFG = dict(
    host="localhost",
    port=5432,
    database="moja_db",
    user="postgres",
    password="123",
)
# E√ö mapovanie ‚Äì keƒè m√°me iba ≈°t√≠tok
LABEL_TO_CODE = {
    # Plasty (1‚Äì7)
    "PET": 1, "PETE": 1,
    "HDPE": 2, "PE-HD": 2,
    "PVC": 3, "V": 3,          # ‚ÄûV‚Äú = PVC
    "LDPE": 4, "PE-LD": 4,
    "PP": 5,
    "PS": 6, "PS-E": 6,
    "O": 7, "OTHER": 7, "PLA": 7,
    # Papier/kart√≥n (20‚Äì22)
    "PAP": 22,
    # Kovy (40‚Äì41)
    "FE": 40,
    "ALU": 41, "AL": 41,
    # Drevo (50), Textil (60), Sklo (70‚Äì72)
    "FOR": 50, "TEX": 60, "GL": 70,
    # Kompozity ‚Äì bezpeƒçn√© defaulty
    "C/PAP": 81,
    "C/ALU": 82, "C/FE": 83,
    "C/PP": 90, "C/PE": 90, "C/LDPE": 90, "C/HDPE": 90,
}
# Legit√≠mne E√ö k√≥dy
EU_VALID = {1,2,3,4,5,6,7,20,21,22,40,41,50,60,70,71,72,81,82,83,84}

# Confidence prahy
LABEL_CONF_OK = 0.40
NUM_CONF_OK   = 0.40

# EasyOCR reader (naƒç√≠ta sa len raz)
READER = easyocr.Reader(['en'], gpu=False, verbose=False)

# ===================== POMOCN√â FUNKCIE =====================

def resolve_desktop_path(user_input: str | None) -> Path:
    """
    Hƒæad√° obr√°zok v tomto porad√≠:
      1) ak user_input je absol√∫tna cesta -> pou≈æije ju
      2) ak user_input je relat√≠vny n√°zov -> najprv images/<name> v repozit√°ri (s√∫bor __file__),
         potom prieƒçinok skriptu, potom Desktop
      3) ak user_input nie je zadan√Ω -> vyhƒæad√° v≈°etky obr√°zky v images/, potom v prieƒçinku skriptu,
         potom na Desktope; ak sa n√°jde viac, zobraz√≠ v√Ωber
    """
    repo_dir = Path(__file__).parent.resolve()      # prieƒçinok, kde je funkcia.py
    images_dir = repo_dir / "images"                 # preferovan√Ω podprieƒçinok
    desktop = Path.home() / "Desktop"

    def collect_from(dir_path: Path) -> list[Path]:
        imgs = []
        for ext in ("*.png", "*.jpg", "*.jpeg", "*.webp", "*.jfif"):
            imgs += list(dir_path.glob(ext)) if dir_path.exists() else []
        return imgs

    # 1) U≈æ√≠vateƒæ zadal nieƒço -> rozl√≠≈°i≈• absol√∫tnu/relat√≠vnu
    if user_input:
        raw = user_input.strip().strip('"').strip("'")
        p = Path(raw)
        if p.is_absolute():
            return p
        # relat√≠vny: najprv images/<name>, potom repo/<name>, potom desktop/<name>
        cand = images_dir / p.name
        if cand.exists():
            return cand
        cand = repo_dir / p.name
        if cand.exists():
            return cand
        cand = desktop / p.name
        if cand.exists():
            return cand
        # ak niƒç z toho nie je, vr√°time relat√≠vnu cestu voƒçi repo (t.j. images/<name> ako fallback)
        return images_dir / p.name

    # 2) user_input nie je zadan√Ω -> hƒæadaj v images/, potom v repo, potom na Desktope
    imgs = collect_from(images_dir)
    if not imgs:
        imgs = collect_from(repo_dir)
    if not imgs:
        imgs = collect_from(desktop)

    if not imgs:
        print("‚ùå Nena≈°iel som ≈æiadne obr√°zky v images/ ani v prieƒçinku skriptu ani na Desktope. Zadaj cestu k s√∫boru:")
        p = input("> ").strip()
        return resolve_desktop_path(p or None)

    imgs.sort(key=lambda x: x.stat().st_mtime, reverse=True)
    print("Na≈°iel som tieto obr√°zky (naposledy upraven√© hore):")
    for i, f in enumerate(imgs[:20], 1):
        print(f"  {i}. {f.name}")
    ch = input("Zadaj ƒç√≠slo (alebo n√°zov s√∫boru, alebo pr√°zdne pre prv√Ω): ").strip()

    # ak u≈æ√≠vateƒæ zadal ƒç√≠slo -> vybra≈• z listu
    if ch.isdigit():
        idx = int(ch) - 1
        if 0 <= idx < len(imgs):
            return imgs[idx]
        print("‚ö†Ô∏è Neplatn√© ƒç√≠slo, pou≈æijem prv√Ω s√∫bor.")
        return imgs[0]

    # ak zadal n√°zov -> skontrolova≈• podobne ako vy≈°≈°ie
    if ch:
        provided = Path(ch)
        if provided.is_absolute() and provided.exists():
            return provided
        # skontroluj images/ a repo/ a desktop/
        for base in (images_dir, repo_dir, desktop):
            cand = base / provided.name
            if cand.exists():
                return cand
        # fallback: assume images/<name>
        return images_dir / provided.name

    # pr√°zdne -> prv√Ω n√°jden√Ω
    return imgs[0]

def _norm_text(t: str) -> str:
    t = t.upper().replace('|', 'I')
    t = re.sub(r'[^A-Z/0-9]', ' ', t)
    return re.sub(r'\s+', ' ', t).strip()

def _center_band_roi(img: np.ndarray) -> np.ndarray:
    """≈†irok√Ω stredn√Ω p√°s ‚Äì aby sa vo≈°iel trojuholn√≠k aj ≈°t√≠tok pod n√≠m."""
    h, w = img.shape[:2]
    y1, y2 = int(h*0.20), int(h*0.92)
    x1, x2 = int(w*0.12), int(w*0.88)
    return img[y1:y2, x1:x2]

def _prep_variants(gray: np.ndarray) -> list[np.ndarray]:
    gray = cv2.medianBlur(gray, 3)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    g2   = clahe.apply(gray)
    thr  = cv2.adaptiveThreshold(g2,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                 cv2.THRESH_BINARY,31,15)
    thri = cv2.adaptiveThreshold(g2,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                 cv2.THRESH_BINARY_INV,31,15)
    thri = cv2.dilate(thri, np.ones((2,2), np.uint8), 1)
    return [g2, thr, thri]

# ===================== CORE: iba EasyOCR =====================

def detect_waste_code(image_path: Path) -> int | None:
    """
    IBA EasyOCR:
      1) n√°jdi ≈°t√≠tok a jeho bbox,
      2) ƒç√≠slo ƒç√≠taj len v p√°se nad ≈°t√≠tkom,
      3) hlasovanie z variantov + heuristiky,
      4) ≈°t√≠tok (conf>=0.60) m√° prioritu.
    """
    img = cv2.imread(str(image_path))
    if img is None:
        print(f"‚ö†Ô∏è Neviem naƒç√≠ta≈• obr√°zok: {image_path}")
        return None

    # zv√§ƒç≈°i pre lep≈°ie OCR + vyre≈æ stred
    M = max(img.shape[:2])
    if M < 1600:
        f = 1600 / M
        img = cv2.resize(img, None, fx=f, fy=f, interpolation=cv2.INTER_CUBIC)

    roi_global = _center_band_roi(img)
    gray = cv2.cvtColor(roi_global, cv2.COLOR_BGR2GRAY)
    gray = cv2.medianBlur(gray, 3)

    # --- 1) EasyOCR: najprv ≈°t√≠tok (PET/PP/ALU/FE/PAP/GL/V/‚Ä¶) ---
    det = READER.readtext(roi_global)  # [(bbox, text, conf), ...]
    label_key, label_conf, label_box = None, 0.0, None

    # zoraden√© podƒæa confidence
    for (bbox, text, conf) in sorted(det, key=lambda x: x[2], reverse=True):
        t = _norm_text(text)
        if t in LABEL_TO_CODE:
            label_key, label_conf = t, conf
            xs = [p[0] for p in bbox]; ys = [p[1] for p in bbox]
            label_box = (int(min(xs)), int(min(ys)), int(max(xs)-min(xs)), int(max(ys)-min(ys)))
            break

    # üî¥ PRIORITA: spoƒæahliv√Ω ≈°t√≠tok rozhoduje okam≈æite
    if label_key and label_conf >= LABEL_CONF_OK:
        # r√Ωchle mapovanie ‚Äûist√Ωch‚Äú ≈°t√≠tkov
        # (PAP a GL maj√∫ defaulty; ak chce≈° 20/21/22 alebo 70/71/72, ƒç√≠tame ƒç√≠slo ni≈æ≈°ie)
        if label_key in ("AL","ALU"):    return 41
        if label_key == "FE":            return 40
        if label_key in ("PET","PETE"):  return 1
        if label_key == "PP":            return 5
        if label_key == "PS":            return 6
        if label_key in ("PVC","V"):     return 3
        if label_key in ("HDPE","PE-HD"):return 2
        if label_key in ("LDPE","PE-LD"):return 4
        # pre PAP/GL/kompozity sa m√¥≈æeme pok√∫si≈• preƒç√≠ta≈• konkr√©tne ƒç√≠slo ni≈æ≈°ie
        # ale ak nie, vr√°tia sa defaulty ni≈æ≈°ie

    # --- 2) urƒçi ROI nad ≈°t√≠tkom (alebo stredn√Ω p√°s), ƒç√≠slo ƒç√≠taj len tam ---
    if label_box:
        lx, ly, lw, lh = label_box
        y_top   = max(0, ly - 3 * lh)
        y_bot   = max(0, ly - int(0.2 * lh))
        x_left  = max(0, lx - lw)
        x_right = min(gray.shape[1], lx + 2 * lw)
        roi_num = gray[y_top:y_bot, x_left:x_right]
        if roi_num.size == 0:
            roi_num = gray
    else:
        gh, gw = gray.shape[:2]
        roi_num = gray[int(gh*0.25):int(gh*0.60), int(gw*0.25):int(gw*0.75)]

    variants = _prep_variants(roi_num)

    # --- 3) EasyOCR ƒç√≠sla (z viacer√Ωch variantov) + hlasovanie ---
    votes: list[int] = []
    for src in [roi_num] + [v for v in variants]:
        # EasyOCR chce 3-kan√°l (BGR)
        if src.ndim == 2:
            src_bgr = cv2.cvtColor(src, cv2.COLOR_GRAY2BGR)
        else:
            src_bgr = src
        d = READER.readtext(src_bgr, detail=1)
        for (_bbox, text, conf) in d:
            if conf < NUM_CONF_OK:
                continue
            t = _norm_text(text)
            # vyber 1‚Äì2 cifry (1..99)
            nums = re.findall(r'\b([1-9]\d?)\b', t)
            votes += [int(n) for n in nums]

    # rozhodni sa z hlasovania (preferuj E√ö k√≥dy)
    code = None
    if votes:
        votes_pref = sorted(votes, key=lambda v: ((v not in EU_VALID), -votes.count(v)))
        code = votes_pref[0]

    # --- 4) Heuristiky a defaulty podƒæa ≈°t√≠tku ---
    if label_key == "PAP":
        # ak sme na≈°li ƒç√≠slo 20/21/22, vr√°≈• ho; inak default 22
        if code in (20,21,22): return code
        return 22
    if label_key == "GL":
        if code in (70,71,72): return code
        return 70

    # typick√Ω omyl PET
    if code in (42, 62):
        return 1

    if code in EU_VALID:
        return code

    # nem√°me spoƒæahliv√© ƒç√≠slo ‚Üí ak aspo≈à nejak√Ω ≈°t√≠tok, vr√°≈• default rodiny
    if label_key in LABEL_TO_CODE:
        return LABEL_TO_CODE[label_key]

    return code  # alebo None

# ===================== DB =====================

def query_db_for_code(code: int) -> str | None:
    conn = psycopg2.connect(**DB_CFG)
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT vysledok FROM hodnoty WHERE cislo = %s", (code,))
            row = cur.fetchone()
            return row[0] if row else None
    finally:
        conn.close()

# ===================== MAIN =====================

def main():
    parser = argparse.ArgumentParser(description="Vyhodnotenie odpadu z fotky (E√ö k√≥dy, EasyOCR only).")
    parser.add_argument("image", nargs="?", help="Cesta k obr√°zku alebo n√°zov s√∫boru z Desktopu.")
    args = parser.parse_args()

    img_path = resolve_desktop_path(args.image)
    if not img_path.exists():
        print(f"‚ùå S√∫bor neexistuje: {img_path}")
        sys.exit(1)

    print(f"üì∑ Sprac√∫vam: {img_path}")
    code = detect_waste_code(img_path)
    if code is None:
        print("‚ùå OCR nena≈°lo pou≈æiteƒæn√Ω E√ö k√≥d (ani ≈°t√≠tok PET/PAP/GL/V‚Ä¶).")
        sys.exit(2)

    print(f"üîé Rozpoznan√Ω E√ö k√≥d: {code}")
    result = query_db_for_code(code)
    if result:
        print(f"‚úÖ V√Ωsledok z DB: {result}")
    else:
        print("‚ÑπÔ∏è V tabuƒæke 'hodnoty' sa nena≈°lo pravidlo pre tento k√≥d.")

if __name__ == "__main__":
    main()
